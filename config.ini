[default]
; Setting verbose to `False` will only output the best license plate number
verbose = 1

; Setting debug to `True` will show plots of the detection/segmentation/OCR
; process
debug = 1

[get_plate_contours]
; Matrix that specifies image pre-warp. Depends on camera parameters.
; [1, 0, 0; 0, 1, 0; 0, 0, 1] for no pre-warping.
;prewarp = [0.84, 0.09, 0; -0.09, 1.09, 0; 0, 0, 1]
prewarp = [1.0, 0, 0; 0, 1, 0; 0, 0, 1]


[extract_plate_candidates]

; Plates with an area lower than this will be silently rejected early
early_reject_min_area = 1000

; If your countries' plates are all the same, the tolerance here can be set
; pretty low (~0.2) if the camera image is good
aspect_ratio.target = 4.72
aspect_ratio.tolerance = 0.8

; Plate dimensions: these may reject many artifacts early if set correctly
width.target = 200
width.tolerance = 0.8

height.target = 75
height.tolerance = 0.8

[segment_plate_candidates]
; Whether or not your plates are inverted.
; Inverted here means LIGHT letters on DARK plates.
; Note that some cameras may invert the image when using infrared.
inverted = 1

; The character height and width in pixels, and the tolerance ratio. Higher
; tolerances will reject bad characters early, but may falsely reject thin
; characters like 'i' or '1' 
letter_height = 30
letter_width = 20
letter_size_tolerance = 0.5

; Minimum and maximum number of characters
; Candidate will be rejected early if fewer contours than `min_num_chars` are
; found in the the cropped plate image
min_num_chars = 6
max_num_chars = 9

[match_plate_candidates]
; Minimum character matching confidence
min_char_score = 0.35

; Where the templates file is located
templates_file = ./templates.npy

; Regex of characters to match
plate_re = [A-Z0-9]
min_num_chars = 6

[postprocess]
json = 1
openalpr_compat = 1
